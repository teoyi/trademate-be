// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: entries.sql

package controller

import (
	"context"
)

const createEntry = `-- name: CreateEntry :one
INSERT INTO entries (
    journal_id,
    instrument, 
    position, 
    lot_size, 
    opening, 
    closing, 
    stop_loss, 
    take_profit, 
    risk_reward, 
    comments,
    before_image, 
    after_image 
) VALUES ( 
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, journal_id, instrument, position, lot_size, opening, closing, stop_loss, take_profit, risk_reward, comments, before_image, after_image, created_at
`

type CreateEntryParams struct {
	JournalID   int64
	Instrument  string
	Position    string
	LotSize     string
	Opening     string
	Closing     string
	StopLoss    string
	TakeProfit  string
	RiskReward  string
	Comments    string
	BeforeImage string
	AfterImage  string
}

func (q *Queries) CreateEntry(ctx context.Context, arg CreateEntryParams) (Entry, error) {
	row := q.db.QueryRowContext(ctx, createEntry,
		arg.JournalID,
		arg.Instrument,
		arg.Position,
		arg.LotSize,
		arg.Opening,
		arg.Closing,
		arg.StopLoss,
		arg.TakeProfit,
		arg.RiskReward,
		arg.Comments,
		arg.BeforeImage,
		arg.AfterImage,
	)
	var i Entry
	err := row.Scan(
		&i.ID,
		&i.JournalID,
		&i.Instrument,
		&i.Position,
		&i.LotSize,
		&i.Opening,
		&i.Closing,
		&i.StopLoss,
		&i.TakeProfit,
		&i.RiskReward,
		&i.Comments,
		&i.BeforeImage,
		&i.AfterImage,
		&i.CreatedAt,
	)
	return i, err
}

const deleteEntry = `-- name: DeleteEntry :exec
DELETE FROM entries WHERE id = $1
`

func (q *Queries) DeleteEntry(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEntry, id)
	return err
}

const getEntry = `-- name: GetEntry :one
SELECT id, journal_id, instrument, position, lot_size, opening, closing, stop_loss, take_profit, risk_reward, comments, before_image, after_image, created_at FROM entries 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetEntry(ctx context.Context, id int64) (Entry, error) {
	row := q.db.QueryRowContext(ctx, getEntry, id)
	var i Entry
	err := row.Scan(
		&i.ID,
		&i.JournalID,
		&i.Instrument,
		&i.Position,
		&i.LotSize,
		&i.Opening,
		&i.Closing,
		&i.StopLoss,
		&i.TakeProfit,
		&i.RiskReward,
		&i.Comments,
		&i.BeforeImage,
		&i.AfterImage,
		&i.CreatedAt,
	)
	return i, err
}

const listEntries = `-- name: ListEntries :many
SELECT id, journal_id, instrument, position, lot_size, opening, closing, stop_loss, take_profit, risk_reward, comments, before_image, after_image, created_at FROM entries 
ORDER BY id 
LIMIT $1 
OFFSET $2
`

type ListEntriesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListEntries(ctx context.Context, arg ListEntriesParams) ([]Entry, error) {
	rows, err := q.db.QueryContext(ctx, listEntries, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Entry{}
	for rows.Next() {
		var i Entry
		if err := rows.Scan(
			&i.ID,
			&i.JournalID,
			&i.Instrument,
			&i.Position,
			&i.LotSize,
			&i.Opening,
			&i.Closing,
			&i.StopLoss,
			&i.TakeProfit,
			&i.RiskReward,
			&i.Comments,
			&i.BeforeImage,
			&i.AfterImage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEntry = `-- name: UpdateEntry :one
UPDATE entries 
SET journal_id = $2, 
    instrument = $3, 
    position = $4, 
    lot_size = $5, 
    opening = $6, 
    closing = $7, 
    stop_loss = $8, 
    take_profit = $9, 
    risk_reward = $10, 
    comments = $11, 
    before_image = $12, 
    after_image = $13
WHERE id = $1
RETURNING id, journal_id, instrument, position, lot_size, opening, closing, stop_loss, take_profit, risk_reward, comments, before_image, after_image, created_at
`

type UpdateEntryParams struct {
	ID          int64
	JournalID   int64
	Instrument  string
	Position    string
	LotSize     string
	Opening     string
	Closing     string
	StopLoss    string
	TakeProfit  string
	RiskReward  string
	Comments    string
	BeforeImage string
	AfterImage  string
}

func (q *Queries) UpdateEntry(ctx context.Context, arg UpdateEntryParams) (Entry, error) {
	row := q.db.QueryRowContext(ctx, updateEntry,
		arg.ID,
		arg.JournalID,
		arg.Instrument,
		arg.Position,
		arg.LotSize,
		arg.Opening,
		arg.Closing,
		arg.StopLoss,
		arg.TakeProfit,
		arg.RiskReward,
		arg.Comments,
		arg.BeforeImage,
		arg.AfterImage,
	)
	var i Entry
	err := row.Scan(
		&i.ID,
		&i.JournalID,
		&i.Instrument,
		&i.Position,
		&i.LotSize,
		&i.Opening,
		&i.Closing,
		&i.StopLoss,
		&i.TakeProfit,
		&i.RiskReward,
		&i.Comments,
		&i.BeforeImage,
		&i.AfterImage,
		&i.CreatedAt,
	)
	return i, err
}
